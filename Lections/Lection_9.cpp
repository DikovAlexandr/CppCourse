Шаблоны функций
Перегрузка - предыдущий подход
template <class T> - Список шаблонных параметров
T abs(T x) { return x < 0 ? -x : x; } - Объявление шаблонной функции

template <typename T> - Список шаблонных параметров
T abs(T x) { return x < 0 ? -x : x; } - Объявление шаблонной функции

template <class T>
T abs(T x, T y) {}

template <class T, class U>
void abs(T x, U y) {}

Нельзя создать функцию без аргументов, тип определяется по типу аргумента

Можно Заставить компилятор создать определенную функцию

template <class T>
T Sum(T x, T y) { return x + y; }

Sum (1, 1) => T = int
Sum <long> (1, 1) => long

Sum <double> (1, 0.0) - модификация только на первую переменную
            int => double

Sum <double, double> (1, 1) => double - модификация на обе переменных

При передаче аргумента по значению тип T определяется по следующим правилам
1) Игнорируются квалификаторы (const, например) - но только у переменных
2) Отбрасываются ссылки
3) Массивы переводятся в указатели
4) Ффнкции переводятся в указатели на функцию
5) Типы которые соответствуют одному шаблонному типу T должны совпадать 
(после выполнения всех действий выше)

template <class T>
T GetZero() { return 0; }

GetZero <double>(); => T = double

template<class T = int>
T GetZero() { return 0; }

Теперь можно: - GetZero (); // OK T = int
              - GetZero <double> (); // OK T = double

Параметры по умолчанию могут быть основаны на предыдущих параметрах

template <class T, class U=T>
U f(T x) {}

f(0) => T = int, U = int
f <float> (0) => T = float, U = T = float
f <int, double> (0) => T = int, U = double

Параметр по умолчанию это не тоже самое что параметр шаблона по умолчанию

Инстанцирование шаблонов

template <class T>
void f(T x) {}

int main() {
    std::cout << "Hello" << std::endl;
    return 0;
}

Тут не будет создано шаблонов функции, так как функция не была вызвана
Инстанцирование - это создание зкземпляра функции.
1) Фаблон функции сам по себе еще не функция
2) Генерация функции не просмходит если шаблон ни разу не вызван
3) Если шаблон вызван то генренируется только нужная функция

template viod f(float); => явное инстанцирование
f(0) => инстанцируется int
f(0.0) => инстанцируется double

Перегрузка шаблонных функций
template <class T, class U>
int f(T x, U y) {return 1;}

template <class T>
int f(T x, T y) {return 2;}

int f(int x, int y) {return 3;}

Правила для перегрузки
1) Точные соответствия всегла побеждают другие случаи
2) Если есть несколько соответствий, то мобеждает соответствие
с меньшим количествои приведений типов
3) При прочих равных побеждает обыкновенная функция, а не шаблон
