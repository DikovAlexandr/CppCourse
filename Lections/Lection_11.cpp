// Конструкторы 
// 1) Параметрический
// 2) Преобразования
// 3) По умолчанию 
// 4) Копирования
// 5) Перемещения

// Параметрический конструктор - обладает >1 аргументом
// Пример
class Stack {
    public:
        Stack (int size, int capacity) {
            int *buf = new int[capacity];
            int val = size;
        }
};

Stack (3, 10);

class B {
    const int x_; // Константа должна быть задана во время инициализации
    int &y_; // То же самое со ссылкой
    public:
        B (int x, int y) {
            x_ = x;
            y_ = y;
        }
};

// Используют списки инициализации
B (int x, int y): x_(x), y_(y) {}

// Конструктор преобразования - принимает один аргумент и используется для преобразования какого-то другого типа
// в объект нашего класса

Stack :: Stack (int size);

// В main
Stack S(1); // Параметрический конструктор создает объект из одного элемента

// Конструктор по умолчанию - ничего не принимает
// Конструктор по умолчанию эквивалентен конструктору с пустым списком инициализации
class A{...}

class B {
    int x;
    A a;
    B() {}; // <=> B(): a() {} - тоже конструктор по умолчанию
};

// Конструкция =default
class B {
    B (int x, int y) {};
    B () = default; // <=> B() {} - эквивалентно созданию конструктора с пустым телом
};

// Конструктор копирования
// Копирование информации из уже существующего объекта того же типа что и создаваемый
// То есть это создание копии
// Конструктор создает объект с помощью другого объекта того же типа путем его копирования
class Stack {
    int *buf_;
    int size_;

    public:
        Stack (const Stack &other) {
            int *buf = new int[other.capacity];
            int val = other.size;
        }
};

Stack :: Stack (const Stack &S): buf_ (new int [S.capacity]), size_ (S.size) {
    for (int i=0; i < S.size; i++) {
        buf_[i] = S.buf_[i];
    }
}

// Деструктор - метод класса необходимый для удаления объекта из памяти
// Он вызывается при удалении объекта. У него нет ни аргументов ни возвращаемого значения
// Его имя должно начинаться с ~
// Деструктор вызывается не явно (явно вызывать его не советуется, так как возможно двойное удаление и прочее)
Stack :: ~Stack () {
    delete [] buf_;
}
// Если не созданного деструктора, компилятор создаст его. Но останется проблема с динамической памятью
// По факту деструктор используется для удаления объектов из динамической памяти
// Конструкторов может быть несколько, а деструктор может быть только один

// Перегрузка операций
// Есть комплексное число 
struct Complex {
    double Re;
    double Im;
};

Complex Sum (const Complex &a, const Complex &b) {
    Complex c;
    c.Re = a.Re + b.Re;
    c.Im = a.Im + b.Im;
    return c;
}

// Но хочется перегрузить операцию сложения два комплексных чисел, чтобы можно было писать a + b
Complex operator+(const Complex& a, const Complex& b) {
    Complex c;
    c.Re = a.Re + b.Re;
    c.Im = a.Im + b.Im;
    return c;
}
// Правила перегрузки операций
// Нельзя переопределять операции над фундаментальными типами
// Нельзя вводить новые операции, например возведение в степень
// Нельзя менять арность и приоритет операции. Арность это количество аргументов в операции (унарный, бинарный)
// Нельзя переопределить некоторые операции, например: 
// :: 
// . 
// .* (разыменовывение и обращение к полю) 
// ?:
// Операции = [] () могут быть перегружены только методом класса
// Операции && и || теряют свойства короткой логики

// Можно сделать перегрузку оператора через метод класса
// В этом случае первый аргумент существует, необходимо указать второй
// Пример перегрузки оператора + для комплексных чисел
Complex Complex::operator+(const Complex& other) {
    Complex result;
    result.Re = this->Re + other.Re;
    result.Im = this->Im + other.Im;
    return result;
}

// Рассмотрим вариант перегрузки оператора + с помощью функции
Complex operator+ (const Complex &x, const Complex &y) {}
// Есть еще конструктор преобразования real -> Complex, тогда
Complex (1, 1) + 2; // OK
3 + Complex (2, 5); // OK
// Если же реализация через метод
Complex Complex::operator+(const Complex& other) {}
Complex (1, 1) + 2; // OK
3 + Complex (2, 5); // Не OK, так как левый аргумент не комплексное число

// Отсюда следует что бинарные операции нужно реализовывать в виде функции, но кроме тех, которые задействуют знак равно
// = += -= *= /= и тд так как равном можно переопределять только в методах
// А вот унарные операции можно переопределять как методы
// Преинкримент и постинкримент - как их различать компилятор
// ++i,           i++
Complex &Complex::operator++() {
    ++Re;
    ++Im;
    return *this;
}

Complex Complex::operator++(int) {
    Complex result = *this;
    ++Re;
    ++Im;
    return result;
}

// Процедура операции присваивания
// x = y = z - может быть перегружена только как метод класса
Complex & Complex::operator=(const Complex &other) {
    Re = other.Re;
    Im = other.Im;
    return *this;
}

Stack a;
Stack b = a; // Это не присваивание, это инициализация через конструктор
Stack & Stack::operator=(const Stack &other) {
    if (this == &other) {
        return *this;
    }
    else {
        delete [] buf_;
        buf_ = new int[other.capacity_];
        size = other.size;
        for (int i = 0; i < size; ++i) {
            buf_[i] = other.buf_[i];
        }
        return *this;
    }
}

Stack a;
int x;
x = x; // Так можно
a = a; // Так нельзя, поспольку элемент будет обращаться к себе же, но уже удаленному на тот момент
